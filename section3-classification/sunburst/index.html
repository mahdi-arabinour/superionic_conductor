<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>[SAFE] Bubble Dot Matrix — Dopant × Structure</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<!-- Plotly -->
<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
<!-- PapaParse -->
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<style>
  :root { --bg:#0f1115; --panel:#171a20; --grid:#2a3240; --text:#e8e8ea; --err:#f87171; --ok:#34d399; }
  * { box-sizing:border-box; }
  body { margin:0; font-family:system-ui,Segoe UI,Roboto,sans-serif; background:var(--bg); color:var(--text); }
  header {
    display:flex; gap:12px; align-items:center; padding:10px 12px;
    background:var(--panel); border-bottom:1px solid var(--grid); position:sticky; top:0; z-index:10; flex-wrap:wrap;
  }
  .ctl { display:flex; align-items:center; gap:6px; font-size:12px; color:#c6c9d2; }
  .ctl input[type="text"], .ctl select{
    background:#111827; color:#e5e7eb; border:1px solid #334155; border-radius:8px; padding:6px 8px;
  }
  .ctl input[type="range"]{ accent-color:#60a5fa; }
  #status { margin-left:auto; font-size:12px; color:#9aa4b2; }
  #error { display:none; padding:8px 12px; background:#2b1111; color:#fecaca; border:1px solid #7f1d1d; border-radius:8px; margin:8px 12px; white-space:pre-wrap; }
  #chart { height:75vh; width:100%; }
  #labelsBar {
    display:flex; flex-wrap:wrap; gap:10px; align-items:center; padding:8px 12px;
    background:#12151b; border-top:1px solid #222838; border-bottom:1px solid #222838; font-size:12px;
  }
  #labelList { display:flex; flex-wrap:wrap; gap:6px; }
  .tag {
    display:inline-flex; align-items:center; gap:6px; background:#1b2030; border:1px solid #2a3240; color:#e5e7eb;
    padding:4px 8px; border-radius:999px;
  }
  .tag button{
    background:transparent; color:#9aa4b2; border:none; cursor:pointer; font-weight:700; line-height:1;
  }
</style>
</head>
<body>
  <header>
    <!-- Overlap/Filter controls -->
    <label class="ctl">Min count
      <input id="minCount" type="range" min="1" max="10" step="1" value="1">
      <span id="minCountVal">1</span>
    </label>
    <label class="ctl">Filter dopants
      <input id="dopantQuery" type="text" placeholder="substring or regex (e.g. ^Al$ or Cl|Br)">
    </label>
    <label class="ctl"><input id="reduceOverlap" type="checkbox"> Reduce label overlap</label>
    <label class="ctl"><input id="wrapLabels" type="checkbox" checked> Wrap dopant labels</label>
    <div id="status">Loading…</div>
  </header>

  <!-- Label controls -->
  <div id="labelsBar">
    <strong style="color:#cbd5e1;">Labels:</strong>
    <label class="ctl">Dopant
      <select id="labelDopant"></select>
    </label>
    <label class="ctl">Structure
      <select id="labelStruct"></select>
    </label>
    <label class="ctl">Text
      <input id="labelText" type="text" placeholder="e.g., High σ here">
    </label>
    <button id="addLabelBtn" class="ctl" style="padding:6px 10px; border-radius:8px; border:1px solid #334155; background:#1f2937; color:#e5e7eb; cursor:pointer;">Add label</button>
    <label class="ctl"><input id="clickToLabel" type="checkbox"> Click bubble to add</label>
    <span style="color:#9aa4b2">Labels align with the bubble (right side).</span>
    <div id="labelList"></div>
  </div>

  <div id="error"></div>
  <div id="chart"></div>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const statusEl = document.getElementById('status');
  const errorEl  = document.getElementById('error');

  // overlap controls
  const minCountEl = document.getElementById('minCount');
  const minCountValEl = document.getElementById('minCountVal');
  const queryEl = document.getElementById('dopantQuery');
  const reduceOverlapEl = document.getElementById('reduceOverlap');
  const wrapLabelsEl = document.getElementById('wrapLabels');

  // label controls
  const labelDopantEl = document.getElementById('labelDopant');
  const labelStructEl = document.getElementById('labelStruct');
  const labelTextEl = document.getElementById('labelText');
  const addLabelBtn = document.getElementById('addLabelBtn');
  const clickToLabelEl = document.getElementById('clickToLabel');
  const labelListEl = document.getElementById('labelList');

  function say(msg, ok=false){ statusEl.textContent = msg; statusEl.style.color = ok ? 'var(--ok)' : '#9aa4b2'; }
  function err(msg){ errorEl.style.display='block'; errorEl.textContent = msg; console.error(msg); }

  if(!window.Plotly){ err("Plotly failed to load from CDN. Check your network or try a VPN."); return; }

  // --- Helpers ---
  const COLS = {
    doping: ["Doping / and or GB Strategy (Normalized)","Doping / and or GB Strategy","Doping","GB Strategy","Doping / GB"],
    structure: ["Structure Family (Canonical)","Structure Group (Canonical)","Structure Family","Structure"],
    sigma: ["Conductivity σ (S/cm) [numeric]","Conductivity σ (S·cm⁻¹) [numeric]","Conductivity σ (S·cm⁻¹)","Conductivity","sigma"]
  };
  function guessCol(headers, candidates){
    const map = Object.fromEntries(headers.map(h=>[h.toLowerCase(), h]));
    for(const name of candidates){ if(map[name.toLowerCase()]) return map[name.toLowerCase()]; }
    for(const h of headers){ const lc=h.toLowerCase(); if(candidates.some(n=>lc.includes(n.toLowerCase()))) return h; }
    return null;
  }
  function toNum(v){
    if(typeof v==="number") return v;
    if(v==null) return NaN;
    const s = String(v).trim();
    if(!s || s==="–" || s==="—" || /^n\/?a$/i.test(s)) return NaN;
    const n = Number(s.replace(/[, ]/g,""));
    if(Number.isFinite(n)) return n;
    const m = s.match(/([+-]?\d*\.?\d+(?:[eE][+-]?\d+)?)/);
    return m ? Number(m[1]) : NaN;
  }
  const SPLIT_RE = /[,;+/]/;
  function explodeDopants(raw){
    if(raw==null || String(raw).trim()==="") return ["(none)"];
    return String(raw).split(SPLIT_RE).map(s=>s.trim()).filter(Boolean);
  }
  function formatDopantLabel(d, wrap){
    if(!wrap) return d;
    return d.replace(/\s*\+\s*/g, "<br>+<br>").replace(/[,/;]\s*/g, "<br>");
  }

  // Globals
  let DATA = null; // { rows, cols }
  let DOPANT_COUNTS = new Map(); // dopant -> count
  let STRUCT_SET = new Set();    // structures
  let LABELS = [];               // {dopant, structure, text}
  let FMT_MAP = new Map();       // raw dopant -> formatted dopant (current)
  let INV_FMT_MAP = new Map();   // formatted -> raw

  function computeDopantCounts(rows, cols){
    const m = new Map();
    const structs = new Set();
    for(const r of rows){
      structs.add((r[cols.structure] ?? "Other / Novel").toString().trim() || "Other / Novel");
      for(const d of explodeDopants(r[cols.doping])) m.set(d, (m.get(d)||0) + 1);
    }
    STRUCT_SET = structs;
    return m;
  }

  function populateLabelOptions(){
    // Dopants
    const dops = Array.from(DOPANT_COUNTS.keys()).sort((a,b)=>a.localeCompare(b, undefined, {numeric:true}));
    labelDopantEl.innerHTML = dops.map(d=>`<option value="${d.replace(/"/g,'&quot;')}">${d}</option>`).join("");
    // Structures
    const structs = Array.from(STRUCT_SET).sort((a,b)=>a.localeCompare(b, undefined, {numeric:true}));
    labelStructEl.innerHTML = structs.map(s=>`<option value="${s.replace(/"/g,'&quot;')}">${s}</option>`).join("");
  }

  function buildAllowedSet(queryStr, minCount){
    const allow = new Set();
    let rx = null;
    const trimmed = (queryStr || "").trim();
    if(trimmed){
      try{ rx = new RegExp(trimmed, "i"); } catch{ rx = null; }
    }
    for(const [dop, cnt] of DOPANT_COUNTS.entries()){
      if(cnt < minCount) continue;
      if(rx){
        if(rx.test(dop)) allow.add(dop);
      } else {
        if(!trimmed || dop.toLowerCase().includes(trimmed.toLowerCase())) allow.add(dop);
      }
    }
    return allow;
  }

  function filterRowsByAllowed(rows, cols, allowed){
    if(!allowed || !allowed.size) return [];
    const out = [];
    for(const r of rows){
      const dops = explodeDopants(r[cols.doping]).filter(d=>allowed.has(d));
      if(!dops.length) continue;
      const clone = {...r};
      clone[cols.doping] = dops.join(" / ");
      out.push(clone);
    }
    return out;
  }

  function buildAnnotations(wrapLabels){
    const ann = [];
    for(const L of LABELS){
      const xCat = FMT_MAP.get(L.dopant) ?? formatDopantLabel(L.dopant, wrapLabels);
      ann.push({
        x: xCat, y: L.structure, xref:'x', yref:'y',
        text: L.text && L.text.trim() ? L.text : `${L.dopant} × ${L.structure}`,
        showarrow:false, xanchor:'left', yanchor:'middle', align:'left',
        xshift:8, yshift:0,
        bgcolor:'rgba(23,26,32,0.7)', bordercolor:'#2a3240', borderwidth:1, borderpad:3,
        font:{color:'#e8e8ea', size:11}
      });
    }
    return ann;
  }

  function renderLabelList(){
    if(!LABELS.length){ labelListEl.innerHTML = ''; return; }
    labelListEl.innerHTML = LABELS.map((L,i)=>(
      `<span class="tag">${L.dopant} × ${L.structure}${L.text?`: ${L.text}`:''}
        <button title="Remove" data-idx="${i}">×</button>
      </span>`
    )).join("");
    labelListEl.querySelectorAll('button').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        const idx = parseInt(btn.getAttribute('data-idx'),10);
        LABELS.splice(idx,1);
        render();
        renderLabelList();
      });
    });
  }

  function draw(rows, cols, opts){
    // bucket: (structure,dopant) -> {vals:[], count}
    const bucket = new Map();
    const structs = new Set();
    const dopants = new Set();

    for(const r of rows){
      const s = toNum(r[cols.sigma]);
      if(!Number.isFinite(s) || s<=0) continue;
      const fam = (r[cols.structure] ?? "Other / Novel").toString().trim() || "Other / Novel";
      const dops = explodeDopants(r[cols.doping]);
      for(const d of dops){
        const key = fam + "|||" + d;
        if(!bucket.has(key)) bucket.set(key, {vals:[], count:0, struct:fam, dop:d});
        const b = bucket.get(key);
        b.vals.push(s); b.count++;
        structs.add(fam); dopants.add(d);
      }
    }

    if(!bucket.size){
      err("No points to plot (no valid σ > 0 after parsing or filters removed everything).");
      Plotly.purge('chart');
      return;
    }

    // Category arrays
    const xCatsRaw = Array.from(dopants).sort((a,b)=>a.localeCompare(b,undefined,{numeric:true}));
    const yCats = Array.from(structs).sort((a,b)=>a.localeCompare(b,undefined,{numeric:true}));

    // Maintain formatted mapping for labels
    FMT_MAP = new Map();
    INV_FMT_MAP = new Map();
    const xCats = xCatsRaw.map(d => {
      const f = formatDopantLabel(d, opts.wrapLabels);
      FMT_MAP.set(d, f); INV_FMT_MAP.set(f, d);
      return f;
    });

    // Build traces
    const x=[], y=[], c=[], sz=[], txt=[];
    let zMin=Infinity, zMax=-Infinity;
    for(const [,b] of bucket){
      const vals = b.vals.slice().sort((a,b)=>a-b);
      const mid = Math.floor(vals.length/2);
      const z = vals.length%2 ? vals[mid] : (vals[mid-1]+vals[mid])/2;
      zMin=Math.min(zMin,z); zMax=Math.max(zMax,z);
      x.push(FMT_MAP.get(b.dop)); // formatted category value
      y.push(b.struct);
      const log10 = Math.log10(z);
      c.push(log10);
      sz.push(Math.max(10, Math.min(60, 10 + Math.log2(b.count+1)*10)));
      txt.push(`${b.struct} × ${b.dop}<br>count: ${b.count}<br>median σ: ${z.toExponential(2)}<br>log₁₀σ: ${log10.toFixed(2)}`);
    }

    // X-axis thinning when crowded
    let xaxis = {
      title:'Dopant', type:'category',
      categoryorder:'array', categoryarray:xCats,
      tickangle: opts.reduceOverlap ? -65 : -30,
      automargin:true, gridcolor:'#2a3240', zerolinecolor:'#2a3240',
      titlefont:{color:'#e8e8ea'}, tickfont:{color:'#e8e8ea', size: opts.reduceOverlap ? 10 : 12}
    };
    if(opts.reduceOverlap){
      const maxTicks = 32;
      const step = Math.max(1, Math.ceil(xCats.length / maxTicks));
      const tickvals = []; const ticktext = [];
      for(let i=0;i<xCats.length;i+=step){ tickvals.push(xCats[i]); ticktext.push(xCats[i]); }
      xaxis.tickmode = 'array'; xaxis.tickvals = tickvals; xaxis.ticktext = ticktext;
    }

    const annotations = buildAnnotations(opts.wrapLabels);

    Plotly.react('chart', [{
      type:'scatter', mode:'markers', x, y, text:txt, hovertemplate:'%{text}<extra></extra>',
      marker:{
        size:sz, sizemode:'diameter',
        color:c, colorscale:'Viridis',
        cmin:Math.log10(zMin), cmax:Math.log10(zMax),
        line:{color:'#111', width:0.5}, opacity:0.9,
        colorbar:{ title:'log₁₀ σ (S·cm⁻¹)', tickfont:{color:'#e8e8ea'}, titlefont:{color:'#e8e8ea'} }
      }
    }], {
      paper_bgcolor:'#0f1115', plot_bgcolor:'#0f1115',
      margin:{t:30,r:10,b: opts.wrapLabels ? 150 : 120,l:200},
      xaxis, 
      yaxis:{ title:'Structure (family)', type:'category', categoryorder:'array', categoryarray:yCats,
              automargin:true, gridcolor:'#2a3240', zerolinecolor:'#2a3240',
              titlefont:{color:'#e8e8ea'}, tickfont:{color:'#e8e8ea'} },
      annotations
    }, {responsive:true, displaylogo:false});

    say(`Rendered ${bucket.size} bubbles · labels: ${LABELS.length} · dopants shown: ${xCatsRaw.length} (min count ≥ ${minCountEl.value})`, true);
  }

  function render(){
    if(!DATA) return;
    const minCount = parseInt(minCountEl.value, 10) || 1;
    const allowed = buildAllowedSet(queryEl.value, minCount);
    const filteredRows = filterRowsByAllowed(DATA.rows, DATA.cols, allowed);
    draw(filteredRows, DATA.cols, {
      wrapLabels: wrapLabelsEl.checked,
      reduceOverlap: reduceOverlapEl.checked
    });
  }

  // --- CSV pipeline with hard checks ---
  function handleParsed(res){
    errorEl.style.display='none';
    if(!res.data || !res.data.length){ err("Parsed file but found no rows."); return; }
    const headers = res.meta.fields || [];
    const cols = {
      doping:   guessCol(headers, COLS.doping),
      structure:guessCol(headers, COLS.structure),
      sigma:    guessCol(headers, COLS.sigma)
    };
    if(!cols.doping || !cols.structure || !cols.sigma){
      err(
`Missing required columns.

Need something like:
- Doping: ${COLS.doping.join(" | ")}
- Structure: ${COLS.structure.join(" | ")}
- Conductivity: ${COLS.sigma.join(" | ")}

Detected headers:
${headers.join(", ")}`
      );
      return;
    }

    DATA = { rows: res.data, cols };
    DOPANT_COUNTS = computeDopantCounts(DATA.rows, DATA.cols);
    populateLabelOptions();

    // set slider max to the observed max count
    const maxCount = Math.max(...DOPANT_COUNTS.values(), 1);
    minCountEl.max = String(Math.max(maxCount, 1));
    minCountEl.value = '1';
    minCountValEl.textContent = '1';

    say("CSV loaded ✓ parsing rows…", true);
    render();
  }

  // --- Controls listeners ---
  minCountEl.addEventListener('input', () => { minCountValEl.textContent = minCountEl.value; render(); });
  queryEl.addEventListener('input', render);
  reduceOverlapEl.addEventListener('change', render);
  wrapLabelsEl.addEventListener('change', render);

  // Add label via controls
  addLabelBtn.addEventListener('click', ()=>{
    const d = labelDopantEl.value;
    const s = labelStructEl.value;
    if(!d || !s) return;
    LABELS.push({ dopant:d, structure:s, text:labelTextEl.value || "" });
    labelTextEl.value = "";
    render();
    renderLabelList();
  });

  // Add label by clicking a bubble (if enabled)
  const chartEl = document.getElementById('chart');
  chartEl.addEventListener('plotly_click', (ev) => {
    if(!clickToLabelEl.checked) return;
    const pt = ev.points && ev.points[0];
    if(!pt) return;
    const fmtX = pt.x;                // formatted dopant category
    const rawD = INV_FMT_MAP.get(fmtX) || fmtX.replace(/<br>/g,' ');
    const rawS = pt.y;
    const text = labelTextEl.value || `${rawD} × ${rawS}`;
    LABELS.push({ dopant:rawD, structure:rawS, text });
    labelTextEl.value = "";
    render();
    renderLabelList();
  });

  // --- Render a tiny sample immediately, then try data.csv ---
  const SAMPLE = `Doping / and or GB Strategy,Structure Family (Canonical),Conductivity σ (S·cm⁻¹)
Al,NASICON,2e-3
Ga,NASICON,1.2e-3
Al + Ga,NASICON,1.7e-3
Al,Garnet,4.0e-4
Li-excess,Argyrodite,1.1e-2
Cl,Halide,9.0e-2
(none),NASICON,6.5e-4
Al + Nb,NASICON,1.8e-3
Cl + Br,Halide,7.0e-2
`;
  Papa.parse(SAMPLE, {header:true, complete: (res) => { handleParsed(res); say("Sample loaded — fetching data.csv…"); }});

  // --- Auto-fetch data.csv (same folder) ---
  fetch("data.csv", { cache: "no-store" })
    .then(resp => {
      if(!resp.ok) throw new Error(`HTTP ${resp.status} ${resp.statusText}`);
      return resp.text();
    })
    .then(csvText => {
      Papa.parse(csvText, {
        header:true,
        dynamicTyping:false,
        skipEmptyLines:true,
        complete: (res) => { handleParsed(res); say("data.csv loaded ✓", true); },
        error: (e)=> err("Parse error: " + e.message)
      });
    })
    .catch(e => {
      say("Using sample data (data.csv not loaded)");
      err("Could not load data.csv automatically: " + e.message + "\n\nEnsure data.csv is in the same folder and the page is served over HTTP (some browsers block fetch via file://).");
    });
});
</script>
</body>
</html>


