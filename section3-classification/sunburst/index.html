<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Sunburst — data.json + Ions & Layered Labels</title>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<style>
  :root { color-scheme: dark; }
  body { margin:0; font-family:system-ui,Segoe UI,Roboto,sans-serif; background:#0f1115; color:#e8e8ea; height:100vh; display:flex; flex-direction:column; }
  header { padding:10px 14px; background:#171a20; display:flex; gap:16px; flex-wrap:wrap; align-items:center; border-bottom:1px solid #262a32; }
  #wrap { flex:1; min-height:0; display:flex; padding:12px 14px; gap:12px; }
  #chartCard { flex:1; display:grid; grid-template-columns: 1fr 340px; gap:14px; }
  .chartBody { background:#101626; border:1px dashed #333a49; border-radius:12px; min-height:640px; position:relative; }
  svg { width:100%; height:100%; display:block; }
  .legend { background:#0f141f; border:1px solid #2a3240; border-radius:12px; padding:10px; overflow:auto; }
  .legend h4 { margin:0 0 8px 0; font-size:12px; color:#cbd5e1; letter-spacing:.4px; text-transform:uppercase; }
  .legendGroup { display:flex; flex-direction:column; gap:6px; }
  .ionRow { display:grid; grid-template-columns: 18px 1fr 18px; gap:10px; align-items:center; padding:6px 8px; border-radius:8px; user-select:none; }
  .ionRow:hover { background:#0f1726; }
  .swatch { width:18px; height:18px; border-radius:4px; border:1px solid rgba(255,255,255,.35); }
  .ionName { cursor:pointer; }
  .chev { width:18px; text-align:center; cursor:pointer; color:#a9b3c8; }
  .sublist { margin-left: 26px; display:none; }
  .sublist.open { display:block; }
  .famRow { display:grid; grid-template-columns: 14px 1fr; gap:8px; align-items:center; padding:4px 6px; border-radius:6px; cursor:pointer; }
  .famRow:hover { background:#0c1322; }
  .smSwatch { width:14px; height:14px; border-radius:3px; border:1px solid rgba(255,255,255,.28); }

  .tooltip { position:fixed; pointer-events:none; background:rgba(0,0,0,.9); color:#fff; padding:8px 10px; border-radius:8px; font-size:12px; line-height:1.3; display:none; z-index:10; box-shadow:0 6px 18px rgba(0,0,0,.45); }
  .dimmed { opacity: .18; transition: opacity .15s ease; }
  .highlight { opacity: 1; transition: opacity .15s ease; }

  /* Labels (stroke halo for contrast) */
  .labelText { fill:#e8e8ea; stroke:#0a0c12; stroke-width:2; paint-order:stroke fill; font-size:12px; }
  .labelPath { fill:none; stroke:none; }
  .labelsControl { display:flex; gap:8px; align-items:center; }
  .labelsControl .group { display:flex; gap:12px; align-items:center; background:#11141a; border:1px solid #30343c; padding:6px 10px; border-radius:10px; }
  .labelsControl label { display:flex; gap:6px; align-items:center; font-size:12px; color:#cbd5e1; }
  .labelsControl input { accent-color:#60a5fa; }
</style>
</head>
<body>
  <header>
    <strong>Sunburst</strong>
    <!-- Only control #1: Labels -->
    <div class="labelsControl">
      <span style="font-size:12px;color:#cbd5e1;letter-spacing:.3px;text-transform:uppercase;">Labels</span>
      <div class="group" id="labelsGroup">
        <label><input type="checkbox" id="cbDepth1" checked> Ions</label>
        <label><input type="checkbox" id="cbDepth2" checked> Families</label>
        <label><input type="checkbox" id="cbDepth3" checked> Subfamilies</label>
        <label><input type="checkbox" id="cbLeaf"   checked> Formulas</label>
      </div>
    </div>
    <!-- Control #2 is the Ions legend at right -->
  </header>

  <div id="wrap">
    <div id="chartCard">
      <div id="chart" class="chartBody"></div>
      <div id="legend" class="legend">
        <h4>Legend</h4>
        <div class="legendGroup"></div>
      </div>
    </div>
  </div>

  <div id="tooltip" class="tooltip"></div>

  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script>
    const chartEl   = document.getElementById('chart');
    const legendEl  = document.getElementById('legend');
    const tooltip   = document.getElementById('tooltip');

    // Labels control checkboxes
    const cbDepth1 = document.getElementById('cbDepth1'); // Ions (depth 1)
    const cbDepth2 = document.getElementById('cbDepth2'); // Families (depth 2)
    const cbDepth3 = document.getElementById('cbDepth3'); // Subfamilies (depth 3)
    const cbLeaf   = document.getElementById('cbLeaf');   // Leaves (no children)

    // Defaults
    const DEF_COND = 1e-6;   // fallback σ (S·cm⁻¹)
    const SCALE_MODE = 'log';

    // Globals for label updates without redrawing arcs
    let dataObj = null;
    let root = null;
    let svgGlobal = null;
    let gArcs = null;
    let gLabels = null;
    let nodesGlobal = null;
    let sideGlobal = null;
    let outerRadiusForGlobal = null;

    const highlightedIons = new Set();
    const highlightedFams = new Set();

    // ---- Load data.json (no upload) ----
    fetch('data.json', { cache: 'no-store' })
      .then(r => { if (!r.ok) throw new Error(`HTTP ${r.status}`); return r.json(); })
      .then(raw => {
        if (!raw || typeof raw !== 'object' || Array.isArray(raw)) throw new Error('data.json must be a hierarchy object');
        dataObj = raw;
        draw();
      })
      .catch(err => {
        console.error('Failed to load data.json:', err);
        alert('Could not load data.json automatically: ' + err.message +
              '\n\nMake sure data.json is in the SAME folder as this HTML and the page is served over HTTP (e.g., http://localhost:8000), not file://');
      });

    [cbDepth1, cbDepth2, cbDepth3, cbLeaf].forEach(cb => cb.addEventListener('change', () => addLabelsLayer()));

    window.addEventListener('resize', () => requestAnimationFrame(draw));

    function obj2children(obj){
      return Object.entries(obj).map(([k,v])=>{
        if(Array.isArray(v)) return {name:k, values:v};
        return {name:k, children:obj2children(v)};
      });
    }

    function computeLeafCond(h, def){
      h.each(n=>{
        if(n.data && n.data.values){
          const vals = n.data.values
            .map(v => (v && typeof v.conductivity_S_per_cm === 'number') ? v.conductivity_S_per_cm : NaN)
            .filter(Number.isFinite);
          n.data.cond = vals.length ? d3.max(vals) : def;
        }
      });
    }

    function draw(){
      if(!dataObj) return;
      chartEl.innerHTML = '';
      const rect = chartEl.getBoundingClientRect();
      const side = Math.floor(Math.min(rect.width || 800, rect.height || 640));
      sideGlobal = side;

      const data = { name:'root', children: obj2children(dataObj) };
      root = d3.hierarchy(data, d=>d.children).sum(()=>1);
      computeLeafCond(root, DEF_COND);

      const svg = d3.select(chartEl).append('svg')
        .attr('width','100%').attr('height','100%')
        .attr('viewBox', `${-side/2} ${-side/2} ${side} ${side}`);
      svgGlobal = svg;

      const ringThickness = Math.max(36, side * 0.06);
      const leafBase      = Math.max(10, side * 0.02);
      const extraLeafMax  = Math.max(110, side * 0.20);

      d3.partition().size([2*Math.PI, (root.height + 1) * ringThickness])(root);

      const leaves = root.leaves();
      let condVals = leaves.map(l => l.data.cond || DEF_COND).filter(Number.isFinite);
      if (!condVals.length) condVals = [DEF_COND];
      let [cmin, cmax] = d3.extent(condVals);
      if (!(cmax > cmin)) { cmin = cmin*0.8; cmax = cmax*1.2; }

      const baseScale = (SCALE_MODE==='linear'
        ? d3.scaleLinear().domain([cmin, cmax])
        : d3.scaleLog().domain([Math.max(cmin, 1e-12), Math.max(cmax, 1e-12)]));
      const condScale = baseScale.range([0, extraLeafMax]).clamp(true);

      const ions = (root.children || []).map(d=>d.data.name);
      const colorIon = d3.scaleOrdinal(ions, d3.quantize(t => d3.interpolateRainbow(t), Math.max(3, ions.length)));

      const outerRadiusFor = d => d.children
        ? d.y1
        : d.y1 + leafBase + condScale(d.data.cond || DEF_COND);
      outerRadiusForGlobal = outerRadiusFor;

      const arc = d3.arc()
        .startAngle(d=>d.x0)
        .endAngle(d=>d.x1)
        .padAngle(d=>Math.min(0.006, (d.x1-d.x0)/6))
        .padRadius(side * 0.45)
        .innerRadius(d=>d.y0)
        .outerRadius(d=> outerRadiusFor(d));

      const g = svg.append('g');
      gArcs = g;

      const nodes = root.descendants().filter(d=>d.depth>0);
      nodesGlobal = nodes;

      const paths = g.selectAll('path')
        .data(nodes)
        .join('path')
        .attr('d', arc)
        .attr('fill', d => { let a=d; while(a.depth>1) a=a.parent; return colorIon(a.data.name); })
        .attr('stroke','#fff').attr('stroke-opacity',0.35).attr('stroke-width', Math.max(0.6, side*0.0012));

      // tag with ion & family for legend highlighting
      paths.each(function(d){
        let ion=d; while(ion && ion.depth>1) ion=ion.parent;
        let fam=d; while(fam && fam.depth>2) fam=fam.parent;
        this.dataset.ion = ion?.data?.name || '';
        this.dataset.family = fam?.data?.name || '';
      });

      // tooltips
      paths.on('mousemove', (evt, d) => {
        const trail = d.ancestors().reverse().slice(1).map(n=>n.data.name).join(' → ');
        let html = `<strong>${trail}</strong>`;
        if (!d.children) {
          const c = d.data.cond || DEF_COND;
          html += `<br/>σ: ${Number.isFinite(c) ? c.toExponential(3) : '(default)'} S·cm⁻¹`;
        }
        tooltip.style.display = 'block';
        tooltip.innerHTML = html;
        tooltip.style.left = (evt.clientX + 10) + 'px';
        tooltip.style.top  = (evt.clientY + 10) + 'px';
      }).on('mouseleave', () => { tooltip.style.display = 'none'; });

      buildLegend(root, colorIon);
      applyHighlight();

      // labels
      addLabelsLayer();
    }

    // Ions control (= legend). Click ion to toggle; expand ▸ to see/toggle families.
    function buildLegend(root, colorIon){
      const group = legendEl.querySelector('.legendGroup');
      group.innerHTML = '';

      (root.children || []).forEach(ionNode => {
        const ion = ionNode.data.name;

        // Ion row: swatch + name + chevron
        const row = document.createElement('div'); row.className='ionRow';
        const sw  = document.createElement('div'); sw.className='swatch'; sw.style.background = colorIon(ion);
        const nm  = document.createElement('div'); nm.className='ionName'; nm.textContent = ion;
        const cv  = document.createElement('div'); cv.className='chev'; cv.textContent = '▸';
        row.appendChild(sw); row.appendChild(nm); row.appendChild(cv);
        group.appendChild(row);

        // Sublist of families (collapsed by default)
        const sub = document.createElement('div'); sub.className='sublist';
        const fams = (ionNode.children||[]).map(n=>n.data.name);
        fams.forEach((fam, i) => {
          const li = document.createElement('div'); li.className='famRow';
          const sm = document.createElement('div'); sm.className='smSwatch';
          sm.style.background = d3.color(colorIon(ion)).brighter(0.5 + (i/(Math.max(2,fams.length)-1||1))*0.9).formatRgb();
          const sn = document.createElement('div'); sn.textContent = fam;
          li.appendChild(sm); li.appendChild(sn);
          sub.appendChild(li);

          // Toggle family highlight on click
          li.addEventListener('click', (ev) => {
            ev.stopPropagation();
            if (highlightedFams.has(fam)) highlightedFams.delete(fam); else highlightedFams.add(fam);
            applyHighlight();
          });
        });
        group.appendChild(sub);

        // Expand/collapse on chevron click
        cv.addEventListener('click', (e) => {
          e.stopPropagation();
          const open = sub.classList.toggle('open');
          cv.textContent = open ? '▾' : '▸';
        });

        // Toggle ion highlight when clicking the name/swatch area
        const toggleIon = () => {
          if (highlightedIons.has(ion)) highlightedIons.delete(ion); else highlightedIons.add(ion);
          applyHighlight();
        };
        nm.addEventListener('click', toggleIon);
        sw.addEventListener('click', toggleIon);
      });
    }

    function applyHighlight(){
      if (!gArcs) return;
      const paths = gArcs.selectAll('path');
      const hasIon = highlightedIons.size > 0;
      const hasFam = highlightedFams.size > 0;

      if (!hasIon && !hasFam){
        paths.classed('dimmed', false).classed('highlight', false);
        return;
      }
      paths.each(function(){
        const ion = this.dataset.ion;
        const fam = this.dataset.family;
        const ionOk = !hasIon || highlightedIons.has(ion);
        const famOk = !hasFam || highlightedFams.has(fam);
        const on = ionOk && famOk;
        this.classList.toggle('highlight', on);
        this.classList.toggle('dimmed', !on);
      });
    }

    // ------- LABELS -------
    function polarToCartesian(cx, cy, r, a){ return [cx + r*Math.cos(a), cy + r*Math.sin(a)]; }

    // Build an arc path for labeling at radius r between angles a0..a1.
    // Reverse path for left-half slices so text stays upright.
    function arcLabelPathD(a0, a1, r){
      const inset = 0.003; // avoid pad seam
      a0 += inset; a1 -= inset;
      const mid = (a0 + a1) / 2;
      let start = a0, end = a1, flip = false;
      if (mid >= Math.PI) { start = a1; end = a0; flip = true; }
      const largeArc = (Math.abs(end - start) % (2*Math.PI)) > Math.PI ? 1 : 0;
      const [sx, sy] = polarToCartesian(0, 0, r, start);
      const [ex, ey] = polarToCartesian(0, 0, r, end);
      // sweep flag depends on direction; 1 for CW, 0 for CCW
      const sweep = flip ? 0 : 1;
      return { d: `M ${sx} ${sy} A ${r} ${r} 0 ${largeArc} ${sweep} ${ex} ${ey}` };
    }

    function addLabelsLayer(){
      if (!svgGlobal || !nodesGlobal) return;

      // remove old labels
      if (gLabels) gLabels.remove();
      gLabels = svgGlobal.append('g');

      const showDepth1 = cbDepth1.checked; // ions
      const showDepth2 = cbDepth2.checked; // families
      const showDepth3 = cbDepth3.checked; // subfamilies
      const showLeaf   = cbLeaf.checked;   // formulas

      const minAngle = 0.004;          // radians; very permissive
      const minRadius = sideGlobal * 0.06;

      const defs = svgGlobal.append('defs');

      // choose candidates
      const labelCandidates = nodesGlobal.filter(d => {
        const isLeaf = !d.children;
        const depthOK =
          (d.depth === 1 && showDepth1) ||
          (d.depth === 2 && showDepth2) ||
          (d.depth === 3 && showDepth3) ||
          (isLeaf      && showLeaf);
        if (!depthOK) return false;
        if ((d.x1 - d.x0) < minAngle) return false;

        // radius for label arc
        d._labelR = isLeaf ? Math.max(outerRadiusForGlobal(d) - 5, d.y1 - 2)
                           : (d.y0 + d.y1) / 2;
        if (d._labelR < minRadius) return false;
        return true;
      });

      // create label paths
      labelCandidates.forEach((d, i) => {
        const { d: pathD } = arcLabelPathD(d.x0, d.x1, d._labelR);
        const p = defs.append('path')
          .attr('id', `lp-${i}`)
          .attr('class', 'labelPath')
          .attr('d', pathD);
        d._labelPathId = `lp-${i}`;
      });

      // place text on paths (SVG2 uses 'href', not 'xlink:href')
      const texts = gLabels.selectAll('text')
        .data(labelCandidates, d => d.data.name + '-' + d.depth)
        .join('text')
        .attr('class', 'labelText');

      const tps = texts.append('textPath')
        .attr('href', d => `#${d._labelPathId}`)
        .attr('startOffset', '50%')
        .style('text-anchor', 'middle')
        .text(d => d.data.name);

      // fit: shrink font 12→7px; if still too long, truncate with ellipsis
      texts.each(function(d){
        const textEl = this;
        const tp = this.querySelector('textPath');
        const pathEl = document.getElementById(d._labelPathId);
        const pathLen = pathEl ? pathEl.getTotalLength() : 0;
        const pad = 8;
        let size = 12;
        textEl.style.fontSize = size + 'px';

        // Try shrinking size
        for (; size >= 7; size--){
          textEl.style.fontSize = size + 'px';
          const needed = tp.getComputedTextLength ? tp.getComputedTextLength() : 1e9;
          if (needed <= pathLen - pad) break;
        }

        if (size < 7){
          // Truncate with ellipsis
          const full = tp.textContent;
          let lo = 1, hi = full.length, ok = 0;
          // binary search max chars that fit
          while (lo <= hi){
            const mid = (lo + hi) >> 1;
            tp.textContent = full.slice(0, mid) + '…';
            const need = tp.getComputedTextLength ? tp.getComputedTextLength() : 1e9;
            if (need <= pathLen - pad){ ok = mid; lo = mid + 1; }
            else { hi = mid - 1; }
          }
          if (ok === 0){
            // give up for ultra-thin wedges
            textEl.style.display = 'none';
          } else {
            tp.textContent = full.slice(0, ok) + '…';
            textEl.style.fontSize = '7px';
          }
        }
      });
    }
  </script>
</body>
</html>
